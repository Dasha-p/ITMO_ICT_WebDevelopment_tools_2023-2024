### Применение `async`, `multiprocessing` и `threading` для I/O-bound задач (получение запросов и запись в базу данных)

#### 1. Применение и выводы

На основании приведенных данных производительности для различных методов при выполнении I/O-bound
задач, можно сделать следующие выводы:

| Метод             | Время выполнения (секунды) |
|-------------------|----------------------------|
| `async`           | 2.054                      |
| `multiprocessing` | 3.017                      |
| `threading`       | 1.742                      |

- **`async` (2.054 секунды)**:
    - Асинхронный метод показывает хорошую производительность для I/O-bound задач, так как позволяет
      эффективно управлять ожиданием сетевых запросов и операций с базой данных.
    - Асинхронное программирование позволяет выполнять другие операции, пока одна задача ожидает
      завершения I/O операции.

- **`multiprocessing` (3.017 секунды)**:
    - Метод `multiprocessing` показывает наихудшую производительность для I/O-bound задач из-за
      накладных расходов на создание и управление процессами.
    - Для чисто I/O-bound задач использование процессов менее эффективно, чем использование потоков
      или асинхронного программирования.

- **`threading` (1.742 секунды)**:
    - Многопоточность показывает лучшую производительность для I/O-bound задач, так как потоки могут
      эффективно переключаться при ожидании I/O операций.
    - Потоки менее затратны по ресурсам по сравнению с процессами и обеспечивают более высокую
      производительность для задач, включающих множество операций ввода-вывода.

### Заключение

- **Asyncio**: Хороший выбор для I/O-bound задач, так как эффективно управляет ожиданием операций
  ввода-вывода. Сложнее в отладке и управлении, но может значительно улучшить производительность для
  высоконагруженных систем.
- **Multiprocessing**: Подходит для CPU-bound задач, но для I/O-bound задач может быть менее
  эффективным из-за накладных расходов на создание процессов.
- **Threading**: Эффективен для I/O-bound задач, позволяет лучше использовать время ожидания
  операций ввода-вывода. Прост в реализации и отладке, но может быть ограничен GIL для CPU-bound
  задач.