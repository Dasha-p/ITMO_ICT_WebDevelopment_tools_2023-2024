### Применение `async`, `multiprocessing` и `threading` в контексте CPU-bound задач

#### 1. Теория

- **`async` (Асинхронное программирование)**:
    - Асинхронное программирование позволяет выполнять задачи асинхронно, используя ключевые
      слова `async` и `await`. Это подходит для задач ввода-вывода (I/O-bound), где можно выполнять
      другие операции, пока одна операция ждет завершения ввода-вывода.
    - Асинхронные операции не параллельны по своей природе; они основаны на кооперативной
      многозадачности, где задачи переключаются при ожидании операций ввода-вывода.
    - Для CPU-bound задач `async` менее эффективен, поскольку задачи не могут выполнять параллельно
      вычисления, но могут переключаться между задачами.

- **`multiprocessing` (Многопроцессорность)**:
    - Модуль `multiprocessing` создает отдельные процессы для выполнения задач. Каждый процесс имеет
      свой собственный интерпретатор Python и память, что позволяет обойти ограничения GIL (Global
      Interpreter Lock).
    - Это идеальный выбор для CPU-bound задач, так как процессы могут выполняться параллельно на
      разных ядрах процессора.
    - Создание и управление процессами дороже по сравнению с потоками, но они обеспечивают настоящий
      параллелизм.

- **`threading` (Многопоточность)**:
    - Модуль `threading` позволяет создавать потоки, которые работают в одном процессе и делят общую
      память. Однако, из-за GIL, только один поток может исполняться в любой момент времени в одном
      процессе.
    - Это подходит для I/O-bound задач, где потоки могут ожидать завершения операций ввода-вывода и
      переключаться между задачами.
    - Для CPU-bound задач многопоточность менее эффективна из-за GIL, который ограничивает
      выполнение нескольких потоков одновременно.

#### 2. Применение и выводы

На основании приведенных данных производительности для различных методов при выполнении CPU-bound
задач разного масштаба, можно сделать следующие выводы:

| Задача      | async (секунды) | multiprocessing (секунды) | threading (секунды) |
|-------------|-----------------|---------------------------|---------------------|
| 1_000_000   | 0.026           | 0.239                     | 0.026               |
| 10_000_000  | 0.286           | 0.381                     | 0.306               |
| 100_000_000 | 2.964           | 0.811                     | 2.959               |

- **1_000_000**:
    - `async` и `threading` показывают одинаковую производительность (0.026 секунды), что
      объясняется малым объемом задачи, который не показывает разницы из-за GIL.
    - `multiprocessing` значительно медленнее (0.239 секунды) из-за накладных расходов на создание
      процессов.

- **10_000_000**:
    - `async` и `threading` снова показывают схожие результаты (0.286 и 0.306 секунды), но оба
      метода начинают демонстрировать более высокие значения времени по мере увеличения объема
      задачи.
    - `multiprocessing` показывает лучшее время (0.381 секунды) по сравнению с `threading`, что
      говорит о лучшем использовании процессорных ресурсов.

- **100_000_000**:
    - `async` и `threading` становятся очень медленными (2.964 и 2.959 секунды), показывая, что они
      не подходят для больших CPU-bound задач.
    - `multiprocessing` значительно быстрее (0.811 секунды), демонстрируя лучший параллелизм и
      использование нескольких ядер процессора.

### Заключение

- **Для I/O-bound задач**:
    - Использование `async` и `threading` будет более подходящим, поскольку они могут эффективно
      управлять ожиданием операций ввода-вывода.

- **Для CPU-bound задач**:
    - `multiprocessing` является предпочтительным выбором, так как позволяет обойти ограничения GIL
      и выполнять задачи параллельно на разных ядрах процессора.
    - `threading` и `async` менее эффективны для больших объемов вычислений из-за ограничений GIL.
